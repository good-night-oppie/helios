
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>l1cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/good-night-oppie/helios-engine/pkg/helios/l1cache/l1cache.go (73.4%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package l1cache

import (
    "sync"

    "github.com/klauspost/compress/zstd"
    "github.com/good-night-oppie/helios-engine/pkg/helios/types"
)

type Cache interface {
    Put(hash types.Hash, raw []byte) (storedBytes int, compressed bool)
    Get(hash types.Hash) (data []byte, ok bool)
    Stats() CacheStats
}

type CacheStats struct {
    Hits      uint64
    Misses    uint64
    Evictions uint64
    SizeBytes uint64
    Items     uint64
}

type Config struct {
    CapacityBytes        int64 // ≤0 means cache is disabled
    CompressionThreshold int   // below threshold: do not compress; ≤0 means always try compress
}

type entry struct {
    k          string
    data       []byte // may be compressed
    rawSize    int
    compressed bool
}

type cache struct {
    mu        sync.Mutex
    capBytes  int64
    sizeBytes int64

    order   []string
    entries map[string]*entry

    enc       *zstd.Encoder
    dec       *zstd.Decoder
    threshold int

    stats CacheStats
}

func New(cfg Config) (Cache, error) <span class="cov8" title="1">{
    if cfg.CapacityBytes &lt; 0 </span><span class="cov0" title="0">{
        cfg.CapacityBytes = 0
    }</span>
    <span class="cov8" title="1">enc, err := zstd.NewWriter(nil)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov8" title="1">dec, err := zstd.NewReader(nil)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov8" title="1">return &amp;cache{
        capBytes:  cfg.CapacityBytes,
        entries:   make(map[string]*entry),
        order:     make([]string, 0, 128),
        enc:       enc,
        dec:       dec,
        threshold: cfg.CompressionThreshold,
    }, nil</span>
}

func (c *cache) key(h types.Hash) string <span class="cov8" title="1">{ return h.String() }</span>

func (c *cache) Put(h types.Hash, raw []byte) (int, bool) <span class="cov8" title="1">{
    if c.capBytes == 0 </span><span class="cov0" title="0">{
        return 0, false
    }</span>
    <span class="cov8" title="1">k := c.key(h)
    var store []byte
    compressed := false
    tryCompress := c.threshold &lt;= 0 || len(raw) &gt;= c.threshold

    c.mu.Lock()
    defer c.mu.Unlock()

    if tryCompress </span><span class="cov8" title="1">{
        comp := c.enc.EncodeAll(raw, nil)
        if len(comp) &lt; len(raw) </span><span class="cov8" title="1">{
            store = comp
            compressed = true
        }</span>
    }
    <span class="cov8" title="1">if store == nil </span><span class="cov8" title="1">{
        store = make([]byte, len(raw))
        copy(store, raw)
    }</span>
    <span class="cov8" title="1">need := int64(len(store))
    if need &gt; c.capBytes </span><span class="cov0" title="0">{
        // object larger than cache capacity → skip caching
        return 0, false
    }</span>

    // if already exists, remove old entry and free space
    <span class="cov8" title="1">if old, ok := c.entries[k]; ok </span><span class="cov0" title="0">{
        c.sizeBytes -= int64(len(old.data))
        c.deleteFromOrder(k)
        delete(c.entries, k)
        c.stats.Items--
    }</span>

    // evict until there is enough space (FIFO)
    <span class="cov8" title="1">for c.sizeBytes+need &gt; c.capBytes &amp;&amp; len(c.order) &gt; 0 </span><span class="cov8" title="1">{
        evictK := c.order[0]
        c.order = c.order[1:]
        if e := c.entries[evictK]; e != nil </span><span class="cov8" title="1">{
            c.sizeBytes -= int64(len(e.data))
            delete(c.entries, evictK)
            c.stats.Evictions++
            c.stats.Items--
        }</span>
    }

    <span class="cov8" title="1">ent := &amp;entry{k: k, data: store, rawSize: len(raw), compressed: compressed}
    c.entries[k] = ent
    c.order = append(c.order, k)
    c.sizeBytes += need
    c.stats.Items++
    c.stats.SizeBytes = uint64(c.sizeBytes)
    return len(store), compressed</span>
}

func (c *cache) Get(h types.Hash) ([]byte, bool) <span class="cov8" title="1">{
    if c.capBytes == 0 </span><span class="cov0" title="0">{
        return nil, false
    }</span>
    <span class="cov8" title="1">k := c.key(h)

    c.mu.Lock()
    defer c.mu.Unlock()

    ent, ok := c.entries[k]
    if !ok </span><span class="cov8" title="1">{
        c.stats.Misses++
        return nil, false
    }</span>

    <span class="cov8" title="1">if ent.compressed </span><span class="cov0" title="0">{
        dec, err := c.dec.DecodeAll(ent.data, nil)
        if err != nil </span><span class="cov0" title="0">{
            // decompression failed, count as miss (do not panic)
            c.stats.Misses++
            return nil, false
        }</span>
        <span class="cov0" title="0">c.stats.Hits++
        return dec, true</span>
    }

    <span class="cov8" title="1">out := make([]byte, len(ent.data))
    copy(out, ent.data)
    c.stats.Hits++
    return out, true</span>
}

func (c *cache) Stats() CacheStats <span class="cov8" title="1">{
    c.mu.Lock()
    defer c.mu.Unlock()
    st := c.stats
    st.SizeBytes = uint64(c.sizeBytes)
    return st
}</span>

func (c *cache) deleteFromOrder(k string) <span class="cov0" title="0">{
    for i := range c.order </span><span class="cov0" title="0">{
        if c.order[i] == k </span><span class="cov0" title="0">{
            copy(c.order[i:], c.order[i+1:])
            c.order = c.order[:len(c.order)-1]
            return
        }</span>
    }
}</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
